% Created 2021-09-30 jeu. 14:00
% Intended LaTeX compiler: pdflatex
\documentclass[letter]{article}
                      \usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{grffile}
\usepackage{longtable}
\usepackage{wrapfig}
\usepackage{rotating}
\usepackage[normalem]{ulem}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{amssymb}
\usepackage{capt-of}
\usepackage{hyperref}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[frenchb, ]{babel}
\usepackage{libertine}
\usepackage[pdftex]{graphicx}
\setlength{\parskip}{1ex plus 0.5ex minus 0.2ex}
\newcommand{\hsp}{\hspace{20pt}}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\date{\today}
\title{Résolution de systèmes linéaires : Méthodes directes}
\begin{document}

%chargement de la page de garde
\input{/home/msi/Documents/Org/Latex/Setupfile/Pagedegarde/Pagedegarde1/pagedegarde1.org}


\setcounter{tocdepth}{2}
\tableofcontents

\newpage




\section{{\bfseries\sffamily TODO} Finir le boulot !! [2/5]}
\label{sec:orgcff7cc2}
\subsection{{\bfseries\sffamily TODO} Présenter les programmes}
\label{sec:org6421796}
\subsection{{\bfseries\sffamily DONE} Le commenter}
\label{sec:orgbc2bf9d}
\subsection{{\bfseries\sffamily DONE} Test les matrices [0/2]:}
\label{sec:org8c9c332}
\subsubsection{{\bfseries\sffamily TODO} Test les matricesau dos de la feuille}
\label{sec:org5f9795d}
\subsubsection{{\bfseries\sffamily TODO} Tester pour des matrices de grandes tailles}
\label{sec:org3e0d7ad}
\subsubsection{{\bfseries\sffamily TODO} Tester pour des matrices avec + de 70\% de 0}
\label{sec:orge4fbfb6}
:CREATED:  \textit{<2021-09-24 ven. 10:52>}
\subsection{{\bfseries\sffamily TODO} Résultats modifiés ?}
\label{sec:org2eb7cd6}
\subsection{{\bfseries\sffamily TODO} Mettre la complexité}
\label{sec:org9b96aab}
\section{Rappel rapide des méthodes}
\label{sec:orgc9755a6}
\subsection{Méthode de Gauss}
\label{sec:org51ce206}
Cette méthode permet de trouver une solution exacte au système \(Ax = b\) en un nombre fini d'étape.


Pour ce faire, cette méthode se fait en plusieurs étapes :

\begin{enumerate}
\item La triangularisation
On doit passer du système \(Ax=b\) au système \(A'x=b'\) où A' est une matrice triangulaire supérieure. L'algorithme utilisé est disponible dans le programme.
\item La résolution facile
\texttt{Nécessite aucun 0 sur la diagonale de A}
\end{enumerate}

\subsection{Méthode de Jacobi}
\label{sec:org8c63b37}

Cette méthode fait partie des méthodes itératives, où l'on cherche à se rapprocher, avec une suite d'itération définie, à une solution exacte.

Pour cette méthode, nous devons tout d'abord décomposer A sous la forme A = D -E -F

\begin{enumerate}
\item D est la matrice nul de taille A, sauf sur sa diagonale où D possède les coefficients de A.
\item -E est la matrice triangulaire inférieure de A
\item -F est la matrice triangulaire supérieur de A
\end{enumerate}



De plus, on pose \(M = D\) et \(N = E + F\)

On obtient donc le système : 

\[Ax = b \Longleftrightarrow Dx^{k+1} = (E + F)x^k + b \]

pour l'itération \(k+1\)

De plus, l'algorithme de Jacobi s'écrit avec une précision \(\epsilon\) : 




\section{Présentation des programmes commentés}
\label{sec:orgea98326}

\subsection{Présentation Général :}
\label{sec:org5d682d9}

\subsubsection{Les différents fichiers utilisés}
\label{sec:orgbc71862}
Pour effectuer ce travail, nous avons décidé de séparer notre programme en plusieurs fichiers : 

\begin{enumerate}
\item main.c, qui est notre fichier appelant les divers fonctions présentent dans
\item fonction.c, puis
\item fonction.h, permettant de définir les différentes structures et les headers des fonctions, et enfin
\item main.h, où les différentes bibliothèques sont déclarées
\item De plus, il y a un Makefile, qui nous permet de compiler et tester notre programme efficacement
\end{enumerate}







\subsubsection{Les structures ainsi que les fonctions de base}
\label{sec:org49241fc}

\subsection{Gauss}
\label{sec:orgb6479e6}

\subsection{Jacobi}
\label{sec:org445e857}

\begin{verbatim}

  matrice *Jacobi(matrice *A, matrice *B, float Eps, int nombremaxinte)
{
  /* gestion des cas d'erreur pouvant faire echouer la methode jacobi*/
  if ((A->largeur != A->longueur) || (A->longueur != B->longueur) ||
      (B->largeur != 1))
  {
    printf(
	"Les matrice ne sont pas de la taille nécessaire a leurs résolution.");
    return B;
  }
  else
  {
    for (int i = 0; i < A->longueur; i++)
    {
      int verifieur = 0;
      for (int j = 0; j < A->longueur; j++)
      {
	if (j != i)
	{
	  verifieur += fabsl(A->Mat[i][j]);
	}
      }
      if (verifieur > A->Mat[i][i])
      {
	printf("La matrice n'est pas à diagonale dominante et ne vas donc pas "
	       "converger...\n");
	return B;
      }
    }
  }

  /* création pour résoudre le système */
  matrice *x = creerMatrice(1, A->longueur);
  matrice *D = creerMatrice(A->largeur, A->longueur);
  matrice *E = creerMatrice(A->largeur, A->longueur);
  matrice *F = creerMatrice(A->largeur, A->longueur);
  matrice *N = creerMatrice(A->largeur, A->longueur);

  /* initialisation de D E et F */
  for (int i = 0; i < A->longueur; i++)
  {
    for (int j = 0; j < A->largeur; j++)
    {
      if (i == j)
      {
	D->Mat[i][j] = A->Mat[i][j];
	E->Mat[i][j] = 0;
	F->Mat[i][j] = 0;
      }
      else if (i < j)
      {
	D->Mat[i][j] = 0;
	E->Mat[i][j] = -(A->Mat[i][j]);
	F->Mat[i][j] = 0;
      }
      else
      {
	D->Mat[i][j] = 0;
	E->Mat[i][j] = 0;
	F->Mat[i][j] = -(A->Mat[i][j]);
      }
      N->Mat[i][j] = E->Mat[i][j] + F->Mat[i][j];
    }
  }

  // initialisation de x
  /* for (int i = 0; i < x->longueur; ++i) */
  /* { */
  /* x->Mat[0][i] = 0; */
  /* } */

  float erreur = Eps + 1;
  InversematriceD(D->longueur, D);

  /* while ((pow(sigma, k)) >= sigma) */
  while (erreur > Eps)
  {
    // nouvelle valeur de x selon la formule
    x = multiplicationMatrice(
	*D, *additionMatrice(*(multiplicationMatrice(*N, *x)), *B));

    // TODO: retirer cette ligne qui annule juste la boucle infini
    erreur = Norme(soustractino(*multiplicationMatrice(*A, *x), *B));
  }
  return x;
}

\end{verbatim}

\subsection{Programme final}
\label{sec:orgc5da4b4}

Les différentes fonctions sont appelées au fur et à mesure du main.c, en laissant le choix à l'utilisateur de son choix. Ceci est regroupé dans un switch.

\section{Présentation des matrices test au dos de la feuille}
\label{sec:org7dbe37d}

\section{Conclusion ssur les méthodes}
\label{sec:orga7c4642}

\subsection{{\bfseries\sffamily TODO} Comparaison}
\label{sec:org2295b65}

\subsection{{\bfseries\sffamily TODO} Cadre d'utilisation}
\label{sec:orgdf00282}

\subsection{{\bfseries\sffamily TODO} Stabilité}
\label{sec:orgdc66548}
Cette méthode a un coût de l'ordre de 3n2+2n par itération. Elle converge moins vite que la méthode de Gauss-Seidel, mais est très facilement parallélisable. 
\end{document}