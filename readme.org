#+Title:Résolution de systèmes linéaires : Méthodes directes


#+LANGUAGE:french
#+OPTIONS: toc:nil %pour ne pas afficher la tdm avant la page de garde

#+OPTIONS: title:nil %pour les subtree propres


#+SETUPFILE:/home/msi/Documents/Org/Latex/Setupfile/Styleslatex/org-plain-latex.org


#+SETUPFILE:/home/msi/Documents/Org/Latex/Setupfile/Pagedegarde/Pagedegarde1/pourpagedegarde1.org




#+BEGIN_EXPORT latex
%chargement de la page de garde
\input{/home/msi/Documents/Org/Latex/Setupfile/Pagedegarde/Pagedegarde1/pagedegarde1.org}
#+END_EXPORT


#+TOC: headlines 2 

\newpage




** TODO Finir le boulot !! [2/5]
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:53>
:END:

*** TODO Présenter les programmes
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:52>
:END:
*** DONE Le commenter
CLOSED: [2021-09-30 jeu. 13:54]
:PROPERTIES:
:CREATED:  <2021-09-30 jeu. 13:54>
:END:
*** DONE Test les matrices [0/2]:
CLOSED: [2021-09-30 jeu. 13:55]
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:55>
:END:
**** TODO Test les matricesau dos de la feuille 
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:55>
:END:
**** TODO Tester pour des matrices de grandes tailles
**** TODO Tester pour des matrices avec + de 70% de 0
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:54>
:END:


:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:52>
:END:
*** TODO Résultats modifiés ?
*** TODO Mettre la complexité
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 10:58>
:END:
** Rappel rapide des méthodes
*** Méthode de Gauss
Cette méthode permet de trouver une solution exacte au système $Ax = b$ en un nombre fini d'étape.


Pour ce faire, cette méthode se fait en plusieurs étapes :

1. La triangularisation
   On doit passer du système $Ax=b$ au système $A'x=b'$ où A' est une matrice triangulaire supérieure. L'algorithme utilisé est disponible dans le programme.
2. La résolution facile
   =Nécessite aucun 0 sur la diagonale de A=

*** Méthode de Jacobi

Cette méthode fait partie des méthodes itératives, où l'on cherche à se rapprocher, avec une suite d'itération définie, à une solution exacte.

Pour cette méthode, nous devons tout d'abord décomposer A sous la forme A = D -E -F

1. D est la matrice nul de taille A, sauf sur sa diagonale où D possède les coefficients de A.
2. -E est la matrice triangulaire inférieure de A
3. -F est la matrice triangulaire supérieur de A



De plus, on pose $M = D$ et $N = E + F$

On obtient donc le système : 

\[Ax = b \Longleftrightarrow Dx^{k+1} = (E + F)x^k + b \]

pour l'itération $k+1$

De plus, l'algorithme de Jacobi s'écrit avec une précision \epsilon : 




** Présentation des programmes commentés

*** Présentation Général :

**** Les différents fichiers utilisés 
Pour effectuer ce travail, nous avons décidé de séparer notre programme en plusieurs fichiers : 

1. main.c, qui est notre fichier appelant les divers fonctions présentent dans
2. fonction.c, puis
3. fonction.h, permettant de définir les différentes structures et les headers des fonctions, et enfin
4. main.h, où les différentes bibliothèques sont déclarées
5. De plus, il y a un Makefile, qui nous permet de compiler et tester notre programme efficacement 
   






**** Les structures ainsi que les fonctions usuelles 

***** La structure de nos matrice

Nous avons choisis de définir notre structure matrice de la sorte :

#+begin_src C
  
  typedef struct matrice
{
  int longueur;
  int largeur;
  long double **Mat;
} matrice;
  
#+end_src

Mettre la longueur et la largeur de la matrice directement dans la structure permet à nos fonction de ne plus les avoir en paramètre. De plus, les matrices sont des doubles tableaux. On utilise dont un pointeur de pointeur pour permettre, grâce à la fonction 


*** Gauss

*** Jacobi

**** Gestion des matrices non diagonales dominantes


Tout d'abord, pour utiliser la méthode de Jacobi, il faut que les matrices soient de la bonne taille. On vérifie donc que la matrice A est carré, que la longueur de A est égal à celle de B, ainsi que la largeur de B qui doit être égal à un. Ces conditions sont testés avec ce code :
#+begin_src C
  
  /* gestion des cas d'erreur pouvant faire echouer la methode jacobi*/
  if ((A->largeur != A->longueur) || (A->longueur != B->longueur) ||
      (B->largeur != 1))
  {
    printf(
	"Les matrice ne sont pas de la taille nécessaire a leurs résolution.");
    return B;
  }
   else
  
  
#+end_src



Puis, il faut aussi que les matrices soient strictement diagonales dominantes.
Pour ce faire, nous pouvons mettre au début de la fonction "Jacobi", une double boucle for qui test si les diagonales sont bien dominantes :

#+begin_src C
  
      else
    {
      for (int i = 0; i < A->longueur; i++)
      {
	int verifieur = 0;
	for (int j = 0; j < A->longueur; j++)
	{
	  if (j != i)
	  {
	    verifieur += fabsl(A->Mat[i][j]);
	  }
	}
	if (verifieur > A->Mat[i][i])
	{
	  printf("La matrice n'est pas à diagonale dominante et ne vas donc pas "
		 "converger...\n");
	  return B;
	}
      }
    }
  
  
#+end_src


Sinon, le reste du code est exécuté normalement.








**** Méthode général

Suites à la création des matrices x, D, E, F (et N) à l'aide des fonction usuelles, il faut les initialiser avec les bonnes valeurs. On a choisit de faire un parcours de la matrice A, et lorsque les conditions sont réunies, nous entrons la valeur de A en fonction de la matrice.

#+begin_src C
      /* initialisation de D E et F (et N)*/
    for (int i = 0; i < A->longueur; i++)
    {
      for (int j = 0; j < A->largeur; j++)
      {
	if (i == j)
	{
	  D->Mat[i][j] = A->Mat[i][j];
	  E->Mat[i][j] = 0;
	  F->Mat[i][j] = 0;
	}
	else if (i < j)
	{
	  D->Mat[i][j] = 0;
	  E->Mat[i][j] = -(A->Mat[i][j]);
	  F->Mat[i][j] = 0;
	}
	else
	{
	  D->Mat[i][j] = 0;
	  E->Mat[i][j] = 0;
	  F->Mat[i][j] = -(A->Mat[i][j]);
	}
	N->Mat[i][j] = E->Mat[i][j] + F->Mat[i][j];
      }
    }
  
  
  #+end_src

Puis, on initialise la marge d'erreur. Nous inversons également D, car il faut utiliser $D^{-1}$

  
  #+begin_src C
    
      float erreur = Eps + 1;
      InversematriceD(D->longueur, D);
    
    
    #+end_src

Enfin, nous programmons la méthode de Jacobi grâce aux fonctions "multiplicationMatrice, additionMatrice".
La boucle utiliser est un tant que, car nous ne savons pas quand la marge d'erreur sera respecté pour sortir de la boucle while.
La variable erreur doit également être mise à jour à chaque passage dans la boucle.

    
    #+begin_src C
      
	while (erreur > Eps)
	{
	  // nouvelle valeur de x selon la formule
	  x = multiplicationMatrice(*D, *additionMatrice(*(multiplicationMatrice(*N, *x)), *B));
	  // nouvelle valeur d'erreur selon la formule
	  erreur = Norme(soustractino(*multiplicationMatrice(*A, *x), *B));
      
	}
	return x;
      }
      
#+end_src

*** Programme final

Les différentes fonctions sont appelées au fur et à mesure du main.c, en laissant le choix à l'utilisateur de son choix. Ceci est regroupé dans un switch.

** Présentation des matrices test au dos de la feuille

** Conclusion ssur les méthodes 

*** TODO Comparaison
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 11:00>
:END:

*** TODO Cadre d'utilisation
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 11:00>
:END:

*** TODO Stabilité
:PROPERTIES:
:CREATED:  <2021-09-24 ven. 11:00>
:END:

Cette méthode a un coût de l'ordre de 3n2+2n par itération. Elle converge moins vite que la méthode de Gauss-Seidel, mais est très facilement parallélisable. 
